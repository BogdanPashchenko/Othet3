= Отчет 3 (По таймеру)

UPD: написано, что легкий, надеюсь, что я правильно делал

== Задание 1.1 
=== Светодиоды должны гореть раз в 500 мс

и просили научным языком, попробую

Для того, чтобы начать работу с таймером сначала нужно подключить библиотеку регистров с таймерами 

После того, как подключили библиотеку и регистры добавили в дерево проекта, чтобы совпадали все файлы, *следует подключить таймер к источнику тактирования.* 

_RCC::APB1ENR::TIM2EN::Enable::Set();

TIM2::CR1::URS::Overflow::Set();_

Мы подключили таймер TIM2, он 32 битный, тактируется от шины APB1, через модуль RCC, что и видно при подключении.

Вторая строка это генерация переполнения, чтобы произошел запрос на прерывание, который реализуется через функцию delay 



_UPD: жуткая функция, на самом деле, самая вредная из всех для меня, пока что_


Далее, мы на паре реализацию кнопки и работу диода с помощью функции Toggle.

_UPD: самое жесткое это правильно посчитать время мигания диода, надеюсь, что я справился с этим, хотя у меня уже есть даже excel-файл для этого)_

После Toggle стоит прописать к какому из Led относится диод, к примеру, Led1 = Led <GPIOC,9>, *что Светодиод Led1 подключен к выводу 9 порта GPIOC* (всё элементарно, как мне кажется, и вроде тут я не должен был ошибаться).

Для того, чтобы по заданию была задержка в 500мс, следует написать 
Led1::Toggle ();
delay (500); 
данная запись и будет обозначать, что будет гореть раз в 500мс

== Задание 1.2
=== Сделать задержку на 500, 1000, 1500 мс, вместо цикла for(..) c с помощью таймера​

Все описание работы рассказал выше, поэтому я просто могу приложить код через бесконечный цикл for

for (; ;)

  {
      Led1::Toggle ();
      delay(500); //pol gorit pol net
      Led2::Toggle ();  
      delay (1000) ;
      Led3::Toggle ();
      delay (1500);
  } 



*Про Delay:*

Delay - функция задержки, прописывается в миллисекундах.
Функция delay() приостанавливает исполнение программы на величину времени time, заданного в миллисекундах.
Данная функция реализуется через функцию void 

void delay(std::uint32_t delay)

{

  TIM2::ARR::Write(16'000 *delay);
  TIM2::SR::UIF::NoUpdate::Set();
  TIM2::CNT::Write(0);
  TIM2::CR1::CEN::Enable::Set();
  while(TIM2::SR::UIF::NoUpdate::IsSet())
   {
   }  
   
};

*ARR* - регистр автоперезагрузки, В этот регистр записывается число, до которого будет идти счет. При достижении этого значения, содержимое счетчика *CNT* обнуляется и формируются прерывание или запрос DMA (если они разрешены).​

в данном случае число  16'000 - конечное.

*CR1* - управляющий регистр, в данном случае CEN отвечает за включение счетчика.

*SR* - регистр статуса, UIF - бит флага прерывания, флаг сброшен.

UPD: порты GPIOC, GPIOA расписывать не буду, там понятно идет подключение регистров MODER5,8,9 как выход, и MODER13 как вход.

Далее, после подключения всех регистров, идет  
реализация кнопки и работу диодов с помощью функции Toggle.

Вот, вроде все новые строки описал, по-моему.


== *Поправки №3*

 1) В delay 16000, потому что используем частоту 16Мгц, и получается, чтобы прописывать значения сразу в мс, а не в нано, то следует домножать на 16000, что и написано в скобках после delay.


 2)extern "C"
{
  int __low_level_init(void)
  {
    RCC::CR::HSION::On::Set();
    while ( !RCC::CR::HSIRDY::Enable::IsSet( ) )
     {

     };

    RCC::CFGR::SW::Hsi::Set();
    while ( !RCC::CFGR::SWS::Hsi::IsSet( ) )
    {

    };

    RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
    RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
    GPIOA::MODER::MODER5::Output::Set() ;
    GPIOC::MODER::MODER5::Output::Set() ;
    GPIOC::MODER::MODER8::Output::Set() ;
    GPIOC::MODER::MODER9::Output::Set() ;
    GPIOC::MODER::MODER13::Input::Set() ;

    RCC::APB1ENR::TIM2EN::Enable::Set() ;
    TIM2::CR1::URS::OverFlow::Set();
    return 0;
  }
}
 
 
Подключение внутренней частоты:

 RCC::CR::HSION::On::Set();

Дальше, нужно дождаться стабилизации через Ready:

   while ( !RCC::CR::HSIRDY::Enable::IsSet( ) )

Назначить источник на системную частоту: 

 RCC::CFGR::SW::Hsi::Set();

И следующее дождаться пока не переключится на системную:

 while ( !RCC::CFGR::SWS::Hsi::IsSet( ) )
 
 
Следующее, что ниже - настройка портов как выходы, а один как вход, ну и с таймером, что я описал выше
 
 Вроде бы всё.
 

