= Отчет 3 (По таймеру)

UPD: написано, что легкий, надеюсь, что я правильно делал

== Задание 1.1 
=== Светодиоды должны гореть раз в 500 мс

и просили научным языком, попробую

Для того, чтобы начать работу с таймером сначала нужно подключить библиотеку регистров с таймерами 

После того, как подключили библиотеку и регистры добавили в дерево проекта, чтобы совпадали все файлы, следует включить подключить таймер 

_RCC::APB1ENR::TIM2EN::Enable::Set();

TIM2::CR1::URS::Overflow::Set();_

Мы подключили таймер TIM2, он 32 битный, тактируется от шины APB1, через модуль RCC, что и видно при подключении.

Вторая строка это генерация переполнения, чтобы произошел запрос на прерывание, который реализуется через функцию delay 



_UPD: жуткая функция, на самом деле, самая вредная из всех для меня, пока что_


Далее, мы на паре реализацию кнопки и работу диода с помощью функции Toggle.

_UPD: самое жесткое это правильно посчитать время мигания диода, надеюсь, что я справился с этим, хотя у меня уже есть даже excel-файл для этого)_

После Toggle стоит прописать к какому из Led относится диод, к примеру, Led1 = Led <GPIOC,9>, означает что к диоду 1 относится 9диод в GPIOC (всё элементарно, как мне кажется, и вроде тут я не должен был ошибаться).

Для того, чтобы по заданию была задержка в 500мс, следует написать 
Led1::Toggle ();
delay (500); 
данная запись и будет обозначать, что будет гореть раз в 500мс

== Задание 1.2
=== Сделать задержку на 500, 1000, 1500 мс, вместо цикла for(..) c с помощью таймера​

Все описание работы рассказал выше, поэтому я просто могу приложить код через бесконечный цикл for

for (; ;)

  {
      Led1::Toggle ();
      delay(500); //pol gorit pol net
      Led2::Toggle ();  
      delay (1000) ;
      Led3::Toggle ();
      delay (1500);
  } 

