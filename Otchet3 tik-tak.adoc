= Отчет 3 (По таймеру)

UPD: написано, что легкий, надеюсь, что я правильно делал

== Задание 1.1 
=== Светодиоды должны гореть раз в 500 мс

и просили научным языком, попробую

Для того, чтобы начать работу с таймером сначала нужно подключить библиотеку регистров с таймерами 

После того, как подключили библиотеку и регистры добавили в дерево проекта, чтобы совпадали все файлы, *следует подключить таймер к источнику тактирования.* 

_RCC::APB1ENR::TIM2EN::Enable::Set();

TIM2::CR1::URS::Overflow::Set();_

Мы подключили таймер TIM2, он 32 битный, тактируется от шины APB1, через модуль RCC, что и видно при подключении.

Вторая строка это генерация переполнения, чтобы произошел запрос на прерывание, который реализуется через функцию delay 



_UPD: жуткая функция, на самом деле, самая вредная из всех для меня, пока что_


Далее, мы на паре реализацию кнопки и работу диода с помощью функции Toggle.

_UPD: самое жесткое это правильно посчитать время мигания диода, надеюсь, что я справился с этим, хотя у меня уже есть даже excel-файл для этого)_

После Toggle стоит прописать к какому из Led относится диод, к примеру, Led1 = Led <GPIOC,9>, *что Светодиод Led1 подключен к выводу 9 порта GPIOC* (всё элементарно, как мне кажется, и вроде тут я не должен был ошибаться).

Для того, чтобы по заданию была задержка в 500мс, следует написать 
Led1::Toggle ();
delay (500); 
данная запись и будет обозначать, что будет гореть раз в 500мс

== Задание 1.2
=== Сделать задержку на 500, 1000, 1500 мс, вместо цикла for(..) c с помощью таймера​

Все описание работы рассказал выше, поэтому я просто могу приложить код через бесконечный цикл for

for (; ;)

  {
      Led1::Toggle ();
      delay(500); //pol gorit pol net
      Led2::Toggle ();  
      delay (1000) ;
      Led3::Toggle ();
      delay (1500);
  } 



*Про Delay:*

Delay - функция задержки, прописывается в миллисекундах.
Функция delay() приостанавливает исполнение программы на величину времени time, заданного в миллисекундах.
Данная функция реализуется через функцию void 

void delay(std::uint32_t delay)

{

  TIM2::ARR::Write(16'000 *delay);
  TIM2::SR::UIF::NoUpdate::Set();
  TIM2::CNT::Write(0);
  TIM2::CR1::CEN::Enable::Set();
  while(TIM2::SR::UIF::NoUpdate::IsSet())
   {
   }  
   
};

*ARR* - регистр автоперезагрузки, В этот регистр записывается число, до которого будет идти счет. При достижении этого значения, содержимое счетчика *CNT* обнуляется и формируются прерывание или запрос DMA (если они разрешены).​

в данном случае число  16'000 - конечное.

*CR1* - управляющий регистр, в данном случае CEN отвечает за включение счетчика.

*SR* - регистр статуса, UIF - бит флага прерывания, флаг сброшен.

UPD: порты GPIOC, GPIOA расписывать не буду, там понятно идет подключение регистров MODER5,8,9 как выход, и MODER13 как вход.

Далее, после подключения всех регистров, идет  
реализация кнопки и работу диодов с помощью функции Toggle.

Вот, вроде все новые строки описал, по-моему.